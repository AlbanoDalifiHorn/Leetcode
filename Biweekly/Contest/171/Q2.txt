class Solution {
    public int[] minOperations(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        
        for (int i = 0; i < n; i++) {
            String s = Integer.toBinaryString(nums[i]);
            if (isBinaryPalindrome(s)) res[i] = 0;
            else {
                int lower = Integer.MAX_VALUE; 
                int higher = Integer.MAX_VALUE;
                int copy_lower = nums[i] - 1;
                int copy_higher = nums[i] + 1;

                while (copy_lower >= 0) {
                    String str = Integer.toBinaryString(copy_lower);
                    if (isBinaryPalindrome(str)) {
                        lower = nums[i] - copy_lower;
                        break;
                    }
                    copy_lower--;
                }

                while (copy_higher <= 5000) {
                    String str = Integer.toBinaryString(copy_higher);
                    if (isBinaryPalindrome(str)) {
                        higher = copy_higher - nums[i];
                        break;
                    }
                    copy_higher++;
                }
                res[i] = Math.min(lower, higher);
            }
        }
        return res;
    }
    
    public static boolean isBinaryPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) return false;
            left++;
            right--;
        }
        return true;
    }
}