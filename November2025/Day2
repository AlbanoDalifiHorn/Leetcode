/*
    Brute force approach by creating a grid matrix with following notation:
        0 = unvisited
        1 = guard
        2 = wall
        3 = visited

    Time Complexity is in O(m * n)

    Steps:
        1. Initialize grid and mark guards/walls
        2. For each guard, traverse in all 4 cardinal directions
        3. Mark cells as guarded (3) until hitting a wall/guard
        4. Count remaining unguarded cells (value = 0)
*/

class Solution {
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        int[][] grid = new int[m][n];
        
        for (int[] guard : guards) grid[guard[0]][guard[1]] = 1;
        for (int[] wall : walls) grid[wall[0]][wall[1]] = 2;

        for (int[] guard : guards) {
            for (int[] dir : new int[][] {{1,0}, {0,1}, {-1,0}, {0,-1}}) {
                int x = dir[0] + guard[0], y = dir[1] + guard[1];

                while (x >= 0 && x < m && y >= 0 && y < n) {
                    if (grid[x][y] == 1 || grid[x][y] == 2) break;
                    grid[x][y] = 3;

                    x += dir[0];
                    y += dir[1];
                }
            }
        }
        int count = 0;
        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (grid[i][j] == 0) count++;
        return count;
    }
}
